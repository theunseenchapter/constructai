<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Test</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #viewer {
            flex: 1;
            border: 2px solid #333;
        }
        #info {
            padding: 10px;
            background-color: #333;
            color: white;
            font-size: 12px;
        }
        #controls {
            padding: 10px;
            background-color: #555;
            color: white;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3>3D Model Test - ConstructAI</h3>
            <button onclick="loadModel()">Load Latest Model</button>
            <button onclick="resetView()">Reset View</button>
            <button onclick="toggleWireframe()">Toggle Wireframe</button>
        </div>
        <div id="viewer"></div>
        <div id="info">
            <div>Status: <span id="status">Ready</span></div>
            <div>Scene ID: <span id="scene-id">None</span></div>
            <div>Vertices: <span id="vertices">0</span></div>
            <div>Faces: <span id="faces">0</span></div>
            <div>Materials: <span id="materials">0</span></div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls, currentModel;
        let wireframe = false;

        // Initialize Three.js
        function init() {
            console.log('ðŸŽ¬ Initializing 3D viewer...');
            
            const container = document.getElementById('viewer');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            
            console.log('âœ… 3D viewer initialized');
            updateStatus('Ready');
        }

        // Load the latest model
        async function loadModel() {
            try {
                updateStatus('Generating new model...');
                console.log('ðŸ“Š Generating new model...');
                
                // Generate a new model
                const response = await fetch('/api/boq/estimate-3d', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: 'Test Model',
                        rooms: [
                            { name: 'Living Room', area: 25 },
                            { name: 'Bedroom', area: 18 },
                            { name: 'Kitchen', area: 15 }
                        ]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const prof3d = data.professional_3d;
                
                if (!prof3d || !prof3d.obj_url || !prof3d.mtl_url) {
                    throw new Error('No 3D model data received');
                }
                
                console.log('ðŸ“¦ Model data received:', prof3d);
                document.getElementById('scene-id').textContent = prof3d.scene_id;
                
                // Load the model
                await loadOBJModel(prof3d.obj_url, prof3d.mtl_url);
                
            } catch (error) {
                console.error('âŒ Error loading model:', error);
                updateStatus('Error: ' + error.message);
            }
        }

        // Load OBJ model with materials
        async function loadOBJModel(objUrl, mtlUrl) {
            try {
                updateStatus('Loading materials...');
                console.log('ðŸ“¦ Loading materials from:', mtlUrl);
                
                // Clear previous model
                if (currentModel) {
                    scene.remove(currentModel);
                }
                
                // Load materials
                const mtlLoader = new THREE.MTLLoader();
                const materials = await new Promise((resolve, reject) => {
                    mtlLoader.load(mtlUrl, resolve, undefined, reject);
                });
                
                materials.preload();
                console.log('âœ… Materials loaded');
                
                updateStatus('Loading geometry...');
                console.log('ðŸ“¦ Loading geometry from:', objUrl);
                
                // Load OBJ
                const objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                
                const object = await new Promise((resolve, reject) => {
                    objLoader.load(objUrl, resolve, undefined, reject);
                });
                
                console.log('âœ… Geometry loaded');
                
                // Calculate statistics
                let vertices = 0, faces = 0, materialCount = 0;
                object.traverse((child) => {
                    if (child.isMesh) {
                        const geometry = child.geometry;
                        if (geometry.attributes.position) {
                            vertices += geometry.attributes.position.count;
                        }
                        if (geometry.index) {
                            faces += geometry.index.count / 3;
                        }
                        if (child.material) {
                            materialCount++;
                        }
                    }
                });
                
                console.log('ðŸ“Š Model statistics:', { vertices, faces, materials: materialCount });
                
                // Update UI
                document.getElementById('vertices').textContent = vertices.toLocaleString();
                document.getElementById('faces').textContent = Math.floor(faces).toLocaleString();
                document.getElementById('materials').textContent = materialCount;
                
                // Position and scale the model
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                object.position.sub(center);
                
                const maxSize = Math.max(size.x, size.y, size.z);
                if (maxSize > 0) {
                    const scale = 8 / maxSize;
                    object.scale.setScalar(scale);
                }
                
                // Add to scene
                scene.add(object);
                currentModel = object;
                
                // Update camera position
                camera.position.set(10, 10, 10);
                camera.lookAt(0, 0, 0);
                
                updateStatus('Model loaded successfully!');
                console.log('âœ… Model added to scene');
                
            } catch (error) {
                console.error('âŒ Error loading OBJ model:', error);
                updateStatus('Error loading model: ' + error.message);
            }
        }

        // Reset camera view
        function resetView() {
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }

        // Toggle wireframe mode
        function toggleWireframe() {
            wireframe = !wireframe;
            if (currentModel) {
                currentModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = wireframe;
                    }
                });
            }
        }

        // Update status text
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
